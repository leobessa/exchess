!function(n){function e(o){if(t[o])return t[o].exports;var i=t[o]={i:o,l:!1,exports:{}};return n[o].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var t={};e.m=n,e.c=t,e.i=function(n){return n},e.d=function(n,t,o){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:o})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="http://localhost:8080/",e(e.s=7)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n__webpack_require__(5);\n\nvar _phoenix = __webpack_require__(4);\n\n(function () {\n  'use strict';\n\n  //------------------------------------------------------------------------------\n  // Chess Util Functions\n  //------------------------------------------------------------------------------\n\n  var COLUMNS = 'abcdefgh'.split('');\n\n  function validMove(move) {\n    // move should be a string\n    if (typeof move !== 'string') return false;\n\n    // move should be in the form of \"e2-e4\", \"f6-d5\"\n    var tmp = move.split('-');\n    if (tmp.length !== 2) return false;\n\n    return validSquare(tmp[0]) === true && validSquare(tmp[1]) === true;\n  }\n\n  function validSquare(square) {\n    if (typeof square !== 'string') return false;\n    return square.search(/^[a-h][1-8]$/) !== -1;\n  }\n\n  function validPieceCode(code) {\n    if (typeof code !== 'string') return false;\n    return code.search(/^[bw][KQRNBP]$/) !== -1;\n  }\n\n  // TODO: this whole function could probably be replaced with a single regex\n  function validFen(fen) {\n    if (typeof fen !== 'string') return false;\n\n    // cut off any move, castling, etc info from the end\n    // we're only interested in position information\n    fen = fen.replace(/ .+$/, '');\n\n    // FEN should be 8 sections separated by slashes\n    var chunks = fen.split('/');\n    if (chunks.length !== 8) return false;\n\n    // check the piece sections\n    for (var i = 0; i < 8; i++) {\n      if (chunks[i] === '' || chunks[i].length > 8 || chunks[i].search(/[^kqrbnpKQRNBP1-8]/) !== -1) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function validPositionObject(pos) {\n    if ((typeof pos === \"undefined\" ? \"undefined\" : _typeof(pos)) !== 'object') return false;\n\n    for (var i in pos) {\n      if (pos.hasOwnProperty(i) !== true) continue;\n\n      if (validSquare(i) !== true || validPieceCode(pos[i]) !== true) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // convert FEN piece code to bP, wK, etc\n  function fenToPieceCode(piece) {\n    // black piece\n    if (piece.toLowerCase() === piece) {\n      return 'b' + piece.toUpperCase();\n    }\n\n    // white piece\n    return 'w' + piece.toUpperCase();\n  }\n\n  // convert bP, wK, etc code to FEN structure\n  function pieceCodeToFen(piece) {\n    var tmp = piece.split('');\n\n    // white piece\n    if (tmp[0] === 'w') {\n      return tmp[1].toUpperCase();\n    }\n\n    // black piece\n    return tmp[1].toLowerCase();\n  }\n\n  // convert FEN string to position object\n  // returns false if the FEN string is invalid\n  function fenToObj(fen) {\n    if (validFen(fen) !== true) {\n      return false;\n    }\n\n    // cut off any move, castling, etc info from the end\n    // we're only interested in position information\n    fen = fen.replace(/ .+$/, '');\n\n    var rows = fen.split('/');\n    var position = {};\n\n    var currentRow = 8;\n    for (var i = 0; i < 8; i++) {\n      var row = rows[i].split('');\n      var colIndex = 0;\n\n      // loop through each character in the FEN section\n      for (var j = 0; j < row.length; j++) {\n        // number / empty squares\n        if (row[j].search(/[1-8]/) !== -1) {\n          var emptySquares = parseInt(row[j], 10);\n          colIndex += emptySquares;\n        }\n        // piece\n        else {\n            var square = COLUMNS[colIndex] + currentRow;\n            position[square] = fenToPieceCode(row[j]);\n            colIndex++;\n          }\n      }\n\n      currentRow--;\n    }\n\n    return position;\n  }\n\n  // position object to FEN string\n  // returns false if the obj is not a valid position object\n  function objToFen(obj) {\n    if (validPositionObject(obj) !== true) {\n      return false;\n    }\n\n    var fen = '';\n\n    var currentRow = 8;\n    for (var i = 0; i < 8; i++) {\n      for (var j = 0; j < 8; j++) {\n        var square = COLUMNS[j] + currentRow;\n\n        // piece exists\n        if (obj.hasOwnProperty(square) === true) {\n          fen += pieceCodeToFen(obj[square]);\n        }\n\n        // empty space\n        else {\n            fen += '1';\n          }\n      }\n\n      if (i !== 7) {\n        fen += '/';\n      }\n\n      currentRow--;\n    }\n\n    // squeeze the numbers together\n    // haha, I love this solution...\n    fen = fen.replace(/11111111/g, '8');\n    fen = fen.replace(/1111111/g, '7');\n    fen = fen.replace(/111111/g, '6');\n    fen = fen.replace(/11111/g, '5');\n    fen = fen.replace(/1111/g, '4');\n    fen = fen.replace(/111/g, '3');\n    fen = fen.replace(/11/g, '2');\n\n    return fen;\n  }\n\n  window['ChessBoard'] = window['ChessBoard'] || function (containerElOrId, cfg) {\n    'use strict';\n\n    cfg = cfg || {};\n\n    //------------------------------------------------------------------------------\n    // Constants\n    //------------------------------------------------------------------------------\n\n    var MINIMUM_JQUERY_VERSION = '1.7.0',\n        START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR',\n        START_POSITION = fenToObj(START_FEN);\n\n    // use unique class names to prevent clashing with anything else on the page\n    // and simplify selectors\n    var CSS = {\n      alpha: 'alpha-d2270',\n      black: 'black-3c85d',\n      board: 'board-b72b1',\n      chessboard: 'chessboard-63f37',\n      clearfix: 'clearfix-7da63',\n      highlight1: 'highlight1-32417',\n      highlight2: 'highlight2-9c5d2',\n      notation: 'notation-322f9',\n      numeric: 'numeric-fc462',\n      piece: 'piece-417db',\n      row: 'row-5277c',\n      sparePieces: 'spare-pieces-7492f',\n      sparePiecesBottom: 'spare-pieces-bottom-ae20f',\n      sparePiecesTop: 'spare-pieces-top-4028b',\n      square: 'square-55d63',\n      white: 'white-1e1d7'\n    };\n\n    //------------------------------------------------------------------------------\n    // Module Scope Variables\n    //------------------------------------------------------------------------------\n\n    // DOM elements\n    var containerEl, boardEl, draggedPieceEl, sparePiecesTopEl, sparePiecesBottomEl;\n\n    // constructor return object\n    var widget = {};\n\n    //------------------------------------------------------------------------------\n    // Stateful\n    //------------------------------------------------------------------------------\n\n    var ANIMATION_HAPPENING = false,\n        BOARD_BORDER_SIZE = 2,\n        CURRENT_ORIENTATION = 'white',\n        CURRENT_POSITION = {},\n        SQUARE_SIZE,\n        DRAGGED_PIECE,\n        DRAGGED_PIECE_LOCATION,\n        DRAGGED_PIECE_SOURCE,\n        DRAGGING_A_PIECE = false,\n        SPARE_PIECE_ELS_IDS = {},\n        SQUARE_ELS_IDS = {},\n        SQUARE_ELS_OFFSETS;\n\n    //------------------------------------------------------------------------------\n    // JS Util Functions\n    //------------------------------------------------------------------------------\n\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n    function createId() {\n      return 'xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx'.replace(/x/g, function (c) {\n        var r = Math.random() * 16 | 0;\n        return r.toString(16);\n      });\n    }\n\n    function deepCopy(thing) {\n      return JSON.parse(JSON.stringify(thing));\n    }\n\n    function parseSemVer(version) {\n      var tmp = version.split('.');\n      return {\n        major: parseInt(tmp[0], 10),\n        minor: parseInt(tmp[1], 10),\n        patch: parseInt(tmp[2], 10)\n      };\n    }\n\n    // returns true if version is >= minimum\n    function compareSemVer(version, minimum) {\n      version = parseSemVer(version);\n      minimum = parseSemVer(minimum);\n\n      var versionNum = version.major * 10000 * 10000 + version.minor * 10000 + version.patch;\n      var minimumNum = minimum.major * 10000 * 10000 + minimum.minor * 10000 + minimum.patch;\n\n      return versionNum >= minimumNum;\n    }\n\n    //------------------------------------------------------------------------------\n    // Validation / Errors\n    //------------------------------------------------------------------------------\n\n    function error(code, msg, obj) {\n      // do nothing if showErrors is not set\n      if (cfg.hasOwnProperty('showErrors') !== true || cfg.showErrors === false) {\n        return;\n      }\n\n      var errorText = 'ChessBoard Error ' + code + ': ' + msg;\n\n      // print to console\n      if (cfg.showErrors === 'console' && (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && typeof console.log === 'function') {\n        console.log(errorText);\n        if (arguments.length >= 2) {\n          console.log(obj);\n        }\n        return;\n      }\n\n      // alert errors\n      if (cfg.showErrors === 'alert') {\n        if (obj) {\n          errorText += '\\n\\n' + JSON.stringify(obj);\n        }\n        window.alert(errorText);\n        return;\n      }\n\n      // custom function\n      if (typeof cfg.showErrors === 'function') {\n        cfg.showErrors(code, msg, obj);\n      }\n    }\n\n    // check dependencies\n    function checkDeps() {\n      // if containerId is a string, it must be the ID of a DOM node\n      if (typeof containerElOrId === 'string') {\n        // cannot be empty\n        if (containerElOrId === '') {\n          window.alert('ChessBoard Error 1001: ' + 'The first argument to ChessBoard() cannot be an empty string.' + '\\n\\nExiting...');\n          return false;\n        }\n\n        // make sure the container element exists in the DOM\n        var el = document.getElementById(containerElOrId);\n        if (!el) {\n          window.alert('ChessBoard Error 1002: Element with id \"' + containerElOrId + '\" does not exist in the DOM.' + '\\n\\nExiting...');\n          return false;\n        }\n\n        // set the containerEl\n        containerEl = $(el);\n      }\n\n      // else it must be something that becomes a jQuery collection\n      // with size 1\n      // ie: a single DOM node or jQuery object\n      else {\n          containerEl = $(containerElOrId);\n\n          if (containerEl.length !== 1) {\n            window.alert('ChessBoard Error 1003: The first argument to ' + 'ChessBoard() must be an ID or a single DOM node.' + '\\n\\nExiting...');\n            return false;\n          }\n        }\n\n      // JSON must exist\n      if (!window.JSON || typeof JSON.stringify !== 'function' || typeof JSON.parse !== 'function') {\n        window.alert('ChessBoard Error 1004: JSON does not exist. ' + 'Please include a JSON polyfill.\\n\\nExiting...');\n        return false;\n      }\n\n      // check for a compatible version of jQuery\n      if (!(_typeof(window.$) && $.fn && $.fn.jquery && compareSemVer($.fn.jquery, MINIMUM_JQUERY_VERSION) === true)) {\n        window.alert('ChessBoard Error 1005: Unable to find a valid version ' + 'of jQuery. Please include jQuery ' + MINIMUM_JQUERY_VERSION + ' or ' + 'higher on the page.\\n\\nExiting...');\n        return false;\n      }\n\n      return true;\n    }\n\n    function validAnimationSpeed(speed) {\n      if (speed === 'fast' || speed === 'slow') {\n        return true;\n      }\n\n      if (parseInt(speed, 10) + '' !== speed + '') {\n        return false;\n      }\n\n      return speed >= 0;\n    }\n\n    // validate config / set default options\n    function expandConfig() {\n      if (typeof cfg === 'string' || validPositionObject(cfg) === true) {\n        cfg = {\n          position: cfg\n        };\n      }\n\n      // default for orientation is white\n      if (cfg.orientation !== 'black') {\n        cfg.orientation = 'white';\n      }\n      CURRENT_ORIENTATION = cfg.orientation;\n\n      // default for showNotation is true\n      if (cfg.showNotation !== false) {\n        cfg.showNotation = true;\n      }\n\n      // default for draggable is false\n      if (cfg.draggable !== true) {\n        cfg.draggable = false;\n      }\n\n      // default for dropOffBoard is 'snapback'\n      if (cfg.dropOffBoard !== 'trash') {\n        cfg.dropOffBoard = 'snapback';\n      }\n\n      // default for sparePieces is false\n      if (cfg.sparePieces !== true) {\n        cfg.sparePieces = false;\n      }\n\n      // draggable must be true if sparePieces is enabled\n      if (cfg.sparePieces === true) {\n        cfg.draggable = true;\n      }\n\n      // default piece theme is wikipedia\n      if (cfg.hasOwnProperty('pieceTheme') !== true || typeof cfg.pieceTheme !== 'string' && typeof cfg.pieceTheme !== 'function') {\n        cfg.pieceTheme = '/images/chesspieces/wikipedia/{piece}.png';\n      }\n\n      // animation speeds\n      if (cfg.hasOwnProperty('appearSpeed') !== true || validAnimationSpeed(cfg.appearSpeed) !== true) {\n        cfg.appearSpeed = 200;\n      }\n      if (cfg.hasOwnProperty('moveSpeed') !== true || validAnimationSpeed(cfg.moveSpeed) !== true) {\n        cfg.moveSpeed = 200;\n      }\n      if (cfg.hasOwnProperty('snapbackSpeed') !== true || validAnimationSpeed(cfg.snapbackSpeed) !== true) {\n        cfg.snapbackSpeed = 50;\n      }\n      if (cfg.hasOwnProperty('snapSpeed') !== true || validAnimationSpeed(cfg.snapSpeed) !== true) {\n        cfg.snapSpeed = 25;\n      }\n      if (cfg.hasOwnProperty('trashSpeed') !== true || validAnimationSpeed(cfg.trashSpeed) !== true) {\n        cfg.trashSpeed = 100;\n      }\n\n      // make sure position is valid\n      if (cfg.hasOwnProperty('position') === true) {\n        if (cfg.position === 'start') {\n          CURRENT_POSITION = deepCopy(START_POSITION);\n        } else if (validFen(cfg.position) === true) {\n          CURRENT_POSITION = fenToObj(cfg.position);\n        } else if (validPositionObject(cfg.position) === true) {\n          CURRENT_POSITION = deepCopy(cfg.position);\n        } else {\n          error(7263, 'Invalid value passed to config.position.', cfg.position);\n        }\n      }\n\n      return true;\n    }\n\n    //------------------------------------------------------------------------------\n    // DOM Misc\n    //------------------------------------------------------------------------------\n\n    // calculates square size based on the width of the container\n    // got a little CSS black magic here, so let me explain:\n    // get the width of the container element (could be anything), reduce by 1 for\n    // fudge factor, and then keep reducing until we find an exact mod 8 for\n    // our square size\n    function calculateSquareSize() {\n      var containerWidth = parseInt(containerEl.css('width'), 10);\n\n      // defensive, prevent infinite loop\n      if (!containerWidth || containerWidth <= 0) {\n        return 0;\n      }\n\n      // pad one pixel\n      var boardWidth = containerWidth - 1;\n\n      while (boardWidth % 8 !== 0 && boardWidth > 0) {\n        boardWidth--;\n      }\n\n      return boardWidth / 8;\n    }\n\n    // create random IDs for elements\n    function createElIds() {\n      // squares on the board\n      for (var i = 0; i < COLUMNS.length; i++) {\n        for (var j = 1; j <= 8; j++) {\n          var square = COLUMNS[i] + j;\n          SQUARE_ELS_IDS[square] = square + '-' + createId();\n        }\n      }\n\n      // spare pieces\n      var pieces = 'KQRBNP'.split('');\n      for (var i = 0; i < pieces.length; i++) {\n        var whitePiece = 'w' + pieces[i];\n        var blackPiece = 'b' + pieces[i];\n        SPARE_PIECE_ELS_IDS[whitePiece] = whitePiece + '-' + createId();\n        SPARE_PIECE_ELS_IDS[blackPiece] = blackPiece + '-' + createId();\n      }\n    }\n\n    //------------------------------------------------------------------------------\n    // Markup Building\n    //------------------------------------------------------------------------------\n\n    function buildBoardContainer() {\n      var html = '<div class=\"' + CSS.chessboard + '\">';\n\n      if (cfg.sparePieces === true) {\n        html += '<div class=\"' + CSS.sparePieces + ' ' + CSS.sparePiecesTop + '\"></div>';\n      }\n\n      html += '<div class=\"' + CSS.board + '\"></div>';\n\n      if (cfg.sparePieces === true) {\n        html += '<div class=\"' + CSS.sparePieces + ' ' + CSS.sparePiecesBottom + '\"></div>';\n      }\n\n      html += '</div>';\n\n      return html;\n    }\n\n    /*\n    var buildSquare = function(color, size, id) {\n      var html = '<div class=\"' + CSS.square + ' ' + CSS[color] + '\" ' +\n      'style=\"width: ' + size + 'px; height: ' + size + 'px\" ' +\n      'id=\"' + id + '\">';\n    \n      if (cfg.showNotation === true) {\n    \n      }\n    \n      html += '</div>';\n    \n      return html;\n    };\n    */\n\n    function buildBoard(orientation) {\n      if (orientation !== 'black') {\n        orientation = 'white';\n      }\n\n      var html = '';\n\n      // algebraic notation / orientation\n      var alpha = deepCopy(COLUMNS);\n      var row = 8;\n      if (orientation === 'black') {\n        alpha.reverse();\n        row = 1;\n      }\n\n      var squareColor = 'white';\n      for (var i = 0; i < 8; i++) {\n        html += '<div class=\"' + CSS.row + '\">';\n        for (var j = 0; j < 8; j++) {\n          var square = alpha[j] + row;\n\n          html += '<div class=\"' + CSS.square + ' ' + CSS[squareColor] + ' ' + 'square-' + square + '\" ' + 'style=\"width: ' + SQUARE_SIZE + 'px; height: ' + SQUARE_SIZE + 'px\" ' + 'id=\"' + SQUARE_ELS_IDS[square] + '\" ' + 'data-square=\"' + square + '\">';\n\n          if (cfg.showNotation === true) {\n            // alpha notation\n            if (orientation === 'white' && row === 1 || orientation === 'black' && row === 8) {\n              html += '<div class=\"' + CSS.notation + ' ' + CSS.alpha + '\">' + alpha[j] + '</div>';\n            }\n\n            // numeric notation\n            if (j === 0) {\n              html += '<div class=\"' + CSS.notation + ' ' + CSS.numeric + '\">' + row + '</div>';\n            }\n          }\n\n          html += '</div>'; // end .square\n\n          squareColor = squareColor === 'white' ? 'black' : 'white';\n        }\n        html += '<div class=\"' + CSS.clearfix + '\"></div></div>';\n\n        squareColor = squareColor === 'white' ? 'black' : 'white';\n\n        if (orientation === 'white') {\n          row--;\n        } else {\n          row++;\n        }\n      }\n\n      return html;\n    }\n\n    function buildPieceImgSrc(piece) {\n      if (typeof cfg.pieceTheme === 'function') {\n        return cfg.pieceTheme(piece);\n      }\n\n      if (typeof cfg.pieceTheme === 'string') {\n        return cfg.pieceTheme.replace(/{piece}/g, piece);\n      }\n\n      // NOTE: this should never happen\n      error(8272, 'Unable to build image source for cfg.pieceTheme.');\n      return '';\n    }\n\n    function buildPiece(piece, hidden, id) {\n      var html = '<img src=\"' + buildPieceImgSrc(piece) + '\" ';\n      if (id && typeof id === 'string') {\n        html += 'id=\"' + id + '\" ';\n      }\n      html += 'alt=\"\" ' + 'class=\"' + CSS.piece + '\" ' + 'data-piece=\"' + piece + '\" ' + 'style=\"width: ' + SQUARE_SIZE + 'px;' + 'height: ' + SQUARE_SIZE + 'px;';\n      if (hidden === true) {\n        html += 'display:none;';\n      }\n      html += '\" />';\n\n      return html;\n    }\n\n    function buildSparePieces(color) {\n      var pieces = ['wK', 'wQ', 'wR', 'wB', 'wN', 'wP'];\n      if (color === 'black') {\n        pieces = ['bK', 'bQ', 'bR', 'bB', 'bN', 'bP'];\n      }\n\n      var html = '';\n      for (var i = 0; i < pieces.length; i++) {\n        html += buildPiece(pieces[i], false, SPARE_PIECE_ELS_IDS[pieces[i]]);\n      }\n\n      return html;\n    }\n\n    //------------------------------------------------------------------------------\n    // Animations\n    //------------------------------------------------------------------------------\n\n    function animateSquareToSquare(src, dest, piece, completeFn) {\n      // get information about the source and destination squares\n      var srcSquareEl = $('#' + SQUARE_ELS_IDS[src]);\n      var srcSquarePosition = srcSquareEl.offset();\n      var destSquareEl = $('#' + SQUARE_ELS_IDS[dest]);\n      var destSquarePosition = destSquareEl.offset();\n\n      // create the animated piece and absolutely position it\n      // over the source square\n      var animatedPieceId = createId();\n      $('body').append(buildPiece(piece, true, animatedPieceId));\n      var animatedPieceEl = $('#' + animatedPieceId);\n      animatedPieceEl.css({\n        display: '',\n        position: 'absolute',\n        top: srcSquarePosition.top,\n        left: srcSquarePosition.left\n      });\n\n      // remove original piece from source square\n      srcSquareEl.find('.' + CSS.piece).remove();\n\n      // on complete\n      var complete = function complete() {\n        // add the \"real\" piece to the destination square\n        destSquareEl.append(buildPiece(piece));\n\n        // remove the animated piece\n        animatedPieceEl.remove();\n\n        // run complete function\n        if (typeof completeFn === 'function') {\n          completeFn();\n        }\n      };\n\n      // animate the piece to the destination square\n      var opts = {\n        duration: cfg.moveSpeed,\n        complete: complete\n      };\n      animatedPieceEl.animate(destSquarePosition, opts);\n    }\n\n    function animateSparePieceToSquare(piece, dest, completeFn) {\n      var srcOffset = $('#' + SPARE_PIECE_ELS_IDS[piece]).offset();\n      var destSquareEl = $('#' + SQUARE_ELS_IDS[dest]);\n      var destOffset = destSquareEl.offset();\n\n      // create the animate piece\n      var pieceId = createId();\n      $('body').append(buildPiece(piece, true, pieceId));\n      var animatedPieceEl = $('#' + pieceId);\n      animatedPieceEl.css({\n        display: '',\n        position: 'absolute',\n        left: srcOffset.left,\n        top: srcOffset.top\n      });\n\n      // on complete\n      var complete = function complete() {\n        // add the \"real\" piece to the destination square\n        destSquareEl.find('.' + CSS.piece).remove();\n        destSquareEl.append(buildPiece(piece));\n\n        // remove the animated piece\n        animatedPieceEl.remove();\n\n        // run complete function\n        if (typeof completeFn === 'function') {\n          completeFn();\n        }\n      };\n\n      // animate the piece to the destination square\n      var opts = {\n        duration: cfg.moveSpeed,\n        complete: complete\n      };\n      animatedPieceEl.animate(destOffset, opts);\n    }\n\n    // execute an array of animations\n    function doAnimations(a, oldPos, newPos) {\n      ANIMATION_HAPPENING = true;\n\n      var numFinished = 0;\n      function onFinish() {\n        numFinished++;\n\n        // exit if all the animations aren't finished\n        if (numFinished !== a.length) return;\n\n        drawPositionInstant();\n        ANIMATION_HAPPENING = false;\n\n        // run their onMoveEnd function\n        if (cfg.hasOwnProperty('onMoveEnd') === true && typeof cfg.onMoveEnd === 'function') {\n          cfg.onMoveEnd(deepCopy(oldPos), deepCopy(newPos));\n        }\n      }\n\n      for (var i = 0; i < a.length; i++) {\n        // clear a piece\n        if (a[i].type === 'clear') {\n          $('#' + SQUARE_ELS_IDS[a[i].square] + ' .' + CSS.piece).fadeOut(cfg.trashSpeed, onFinish);\n        }\n\n        // add a piece (no spare pieces)\n        if (a[i].type === 'add' && cfg.sparePieces !== true) {\n          $('#' + SQUARE_ELS_IDS[a[i].square]).append(buildPiece(a[i].piece, true)).find('.' + CSS.piece).fadeIn(cfg.appearSpeed, onFinish);\n        }\n\n        // add a piece from a spare piece\n        if (a[i].type === 'add' && cfg.sparePieces === true) {\n          animateSparePieceToSquare(a[i].piece, a[i].square, onFinish);\n        }\n\n        // move a piece\n        if (a[i].type === 'move') {\n          animateSquareToSquare(a[i].source, a[i].destination, a[i].piece, onFinish);\n        }\n      }\n    }\n\n    // returns the distance between two squares\n    function squareDistance(s1, s2) {\n      s1 = s1.split('');\n      var s1x = COLUMNS.indexOf(s1[0]) + 1;\n      var s1y = parseInt(s1[1], 10);\n\n      s2 = s2.split('');\n      var s2x = COLUMNS.indexOf(s2[0]) + 1;\n      var s2y = parseInt(s2[1], 10);\n\n      var xDelta = Math.abs(s1x - s2x);\n      var yDelta = Math.abs(s1y - s2y);\n\n      if (xDelta >= yDelta) return xDelta;\n      return yDelta;\n    }\n\n    // returns an array of closest squares from square\n    function createRadius(square) {\n      var squares = [];\n\n      // calculate distance of all squares\n      for (var i = 0; i < 8; i++) {\n        for (var j = 0; j < 8; j++) {\n          var s = COLUMNS[i] + (j + 1);\n\n          // skip the square we're starting from\n          if (square === s) continue;\n\n          squares.push({\n            square: s,\n            distance: squareDistance(square, s)\n          });\n        }\n      }\n\n      // sort by distance\n      squares.sort(function (a, b) {\n        return a.distance - b.distance;\n      });\n\n      // just return the square code\n      var squares2 = [];\n      for (var i = 0; i < squares.length; i++) {\n        squares2.push(squares[i].square);\n      }\n\n      return squares2;\n    }\n\n    // returns the square of the closest instance of piece\n    // returns false if no instance of piece is found in position\n    function findClosestPiece(position, piece, square) {\n      // create array of closest squares from square\n      var closestSquares = createRadius(square);\n\n      // search through the position in order of distance for the piece\n      for (var i = 0; i < closestSquares.length; i++) {\n        var s = closestSquares[i];\n\n        if (position.hasOwnProperty(s) === true && position[s] === piece) {\n          return s;\n        }\n      }\n\n      return false;\n    }\n\n    // calculate an array of animations that need to happen in order to get\n    // from pos1 to pos2\n    function calculateAnimations(pos1, pos2) {\n      // make copies of both\n      pos1 = deepCopy(pos1);\n      pos2 = deepCopy(pos2);\n\n      var animations = [];\n      var squaresMovedTo = {};\n\n      // remove pieces that are the same in both positions\n      for (var i in pos2) {\n        if (pos2.hasOwnProperty(i) !== true) continue;\n\n        if (pos1.hasOwnProperty(i) === true && pos1[i] === pos2[i]) {\n          delete pos1[i];\n          delete pos2[i];\n        }\n      }\n\n      // find all the \"move\" animations\n      for (var i in pos2) {\n        if (pos2.hasOwnProperty(i) !== true) continue;\n\n        var closestPiece = findClosestPiece(pos1, pos2[i], i);\n        if (closestPiece !== false) {\n          animations.push({\n            type: 'move',\n            source: closestPiece,\n            destination: i,\n            piece: pos2[i]\n          });\n\n          delete pos1[closestPiece];\n          delete pos2[i];\n          squaresMovedTo[i] = true;\n        }\n      }\n\n      // add pieces to pos2\n      for (var i in pos2) {\n        if (pos2.hasOwnProperty(i) !== true) continue;\n\n        animations.push({\n          type: 'add',\n          square: i,\n          piece: pos2[i]\n        });\n\n        delete pos2[i];\n      }\n\n      // clear pieces from pos1\n      for (var i in pos1) {\n        if (pos1.hasOwnProperty(i) !== true) continue;\n\n        // do not clear a piece if it is on a square that is the result\n        // of a \"move\", ie: a piece capture\n        if (squaresMovedTo.hasOwnProperty(i) === true) continue;\n\n        animations.push({\n          type: 'clear',\n          square: i,\n          piece: pos1[i]\n        });\n\n        delete pos1[i];\n      }\n\n      return animations;\n    }\n\n    //------------------------------------------------------------------------------\n    // Control Flow\n    //------------------------------------------------------------------------------\n\n    function drawPositionInstant() {\n      // clear the board\n      boardEl.find('.' + CSS.piece).remove();\n\n      // add the pieces\n      for (var i in CURRENT_POSITION) {\n        if (CURRENT_POSITION.hasOwnProperty(i) !== true) continue;\n\n        $('#' + SQUARE_ELS_IDS[i]).append(buildPiece(CURRENT_POSITION[i]));\n      }\n    }\n\n    function drawBoard() {\n      boardEl.html(buildBoard(CURRENT_ORIENTATION));\n      drawPositionInstant();\n\n      if (cfg.sparePieces === true) {\n        if (CURRENT_ORIENTATION === 'white') {\n          sparePiecesTopEl.html(buildSparePieces('black'));\n          sparePiecesBottomEl.html(buildSparePieces('white'));\n        } else {\n          sparePiecesTopEl.html(buildSparePieces('white'));\n          sparePiecesBottomEl.html(buildSparePieces('black'));\n        }\n      }\n    }\n\n    // given a position and a set of moves, return a new position\n    // with the moves executed\n    function calculatePositionFromMoves(position, moves) {\n      position = deepCopy(position);\n\n      for (var i in moves) {\n        if (moves.hasOwnProperty(i) !== true) continue;\n\n        // skip the move if the position doesn't have a piece on the source square\n        if (position.hasOwnProperty(i) !== true) continue;\n\n        var piece = position[i];\n        delete position[i];\n        position[moves[i]] = piece;\n      }\n\n      return position;\n    }\n\n    function setCurrentPosition(position) {\n      var oldPos = deepCopy(CURRENT_POSITION);\n      var newPos = deepCopy(position);\n      var oldFen = objToFen(oldPos);\n      var newFen = objToFen(newPos);\n\n      // do nothing if no change in position\n      if (oldFen === newFen) return;\n\n      // run their onChange function\n      if (cfg.hasOwnProperty('onChange') === true && typeof cfg.onChange === 'function') {\n        cfg.onChange(oldPos, newPos);\n      }\n\n      // update state\n      CURRENT_POSITION = position;\n    }\n\n    function isXYOnSquare(x, y) {\n      for (var i in SQUARE_ELS_OFFSETS) {\n        if (SQUARE_ELS_OFFSETS.hasOwnProperty(i) !== true) continue;\n\n        var s = SQUARE_ELS_OFFSETS[i];\n        if (x >= s.left && x < s.left + SQUARE_SIZE && y >= s.top && y < s.top + SQUARE_SIZE) {\n          return i;\n        }\n      }\n\n      return 'offboard';\n    }\n\n    // records the XY coords of every square into memory\n    function captureSquareOffsets() {\n      SQUARE_ELS_OFFSETS = {};\n\n      for (var i in SQUARE_ELS_IDS) {\n        if (SQUARE_ELS_IDS.hasOwnProperty(i) !== true) continue;\n\n        SQUARE_ELS_OFFSETS[i] = $('#' + SQUARE_ELS_IDS[i]).offset();\n      }\n    }\n\n    function removeSquareHighlights() {\n      boardEl.find('.' + CSS.square).removeClass(CSS.highlight1 + ' ' + CSS.highlight2);\n    }\n\n    function snapbackDraggedPiece() {\n      // there is no \"snapback\" for spare pieces\n      if (DRAGGED_PIECE_SOURCE === 'spare') {\n        trashDraggedPiece();\n        return;\n      }\n\n      removeSquareHighlights();\n\n      // animation complete\n      function complete() {\n        drawPositionInstant();\n        draggedPieceEl.css('display', 'none');\n\n        // run their onSnapbackEnd function\n        if (cfg.hasOwnProperty('onSnapbackEnd') === true && typeof cfg.onSnapbackEnd === 'function') {\n          cfg.onSnapbackEnd(DRAGGED_PIECE, DRAGGED_PIECE_SOURCE, deepCopy(CURRENT_POSITION), CURRENT_ORIENTATION);\n        }\n      }\n\n      // get source square position\n      var sourceSquarePosition = $('#' + SQUARE_ELS_IDS[DRAGGED_PIECE_SOURCE]).offset();\n\n      // animate the piece to the target square\n      var opts = {\n        duration: cfg.snapbackSpeed,\n        complete: complete\n      };\n      draggedPieceEl.animate(sourceSquarePosition, opts);\n\n      // set state\n      DRAGGING_A_PIECE = false;\n    }\n\n    function trashDraggedPiece() {\n      removeSquareHighlights();\n\n      // remove the source piece\n      var newPosition = deepCopy(CURRENT_POSITION);\n      delete newPosition[DRAGGED_PIECE_SOURCE];\n      setCurrentPosition(newPosition);\n\n      // redraw the position\n      drawPositionInstant();\n\n      // hide the dragged piece\n      draggedPieceEl.fadeOut(cfg.trashSpeed);\n\n      // set state\n      DRAGGING_A_PIECE = false;\n    }\n\n    function dropDraggedPieceOnSquare(square) {\n      removeSquareHighlights();\n\n      // update position\n      var newPosition = deepCopy(CURRENT_POSITION);\n      delete newPosition[DRAGGED_PIECE_SOURCE];\n      newPosition[square] = DRAGGED_PIECE;\n      setCurrentPosition(newPosition);\n\n      // get target square information\n      var targetSquarePosition = $('#' + SQUARE_ELS_IDS[square]).offset();\n\n      // animation complete\n      var complete = function complete() {\n        drawPositionInstant();\n        draggedPieceEl.css('display', 'none');\n\n        // execute their onSnapEnd function\n        if (cfg.hasOwnProperty('onSnapEnd') === true && typeof cfg.onSnapEnd === 'function') {\n          cfg.onSnapEnd(DRAGGED_PIECE_SOURCE, square, DRAGGED_PIECE);\n        }\n      };\n\n      // snap the piece to the target square\n      var opts = {\n        duration: cfg.snapSpeed,\n        complete: complete\n      };\n      draggedPieceEl.animate(targetSquarePosition, opts);\n\n      // set state\n      DRAGGING_A_PIECE = false;\n    }\n\n    function beginDraggingPiece(source, piece, x, y) {\n      // run their custom onDragStart function\n      // their custom onDragStart function can cancel drag start\n      if (typeof cfg.onDragStart === 'function' && cfg.onDragStart(source, piece, deepCopy(CURRENT_POSITION), CURRENT_ORIENTATION) === false) {\n        return;\n      }\n\n      // set state\n      DRAGGING_A_PIECE = true;\n      DRAGGED_PIECE = piece;\n      DRAGGED_PIECE_SOURCE = source;\n\n      // if the piece came from spare pieces, location is offboard\n      if (source === 'spare') {\n        DRAGGED_PIECE_LOCATION = 'offboard';\n      } else {\n        DRAGGED_PIECE_LOCATION = source;\n      }\n\n      // capture the x, y coords of all squares in memory\n      captureSquareOffsets();\n\n      // create the dragged piece\n      draggedPieceEl.attr('src', buildPieceImgSrc(piece)).css({\n        display: '',\n        position: 'absolute',\n        left: x - SQUARE_SIZE / 2,\n        top: y - SQUARE_SIZE / 2\n      });\n\n      if (source !== 'spare') {\n        // highlight the source square and hide the piece\n        $('#' + SQUARE_ELS_IDS[source]).addClass(CSS.highlight1).find('.' + CSS.piece).css('display', 'none');\n      }\n    }\n\n    function updateDraggedPiece(x, y) {\n      // put the dragged piece over the mouse cursor\n      draggedPieceEl.css({\n        left: x - SQUARE_SIZE / 2,\n        top: y - SQUARE_SIZE / 2\n      });\n\n      // get location\n      var location = isXYOnSquare(x, y);\n\n      // do nothing if the location has not changed\n      if (location === DRAGGED_PIECE_LOCATION) return;\n\n      // remove highlight from previous square\n      if (validSquare(DRAGGED_PIECE_LOCATION) === true) {\n        $('#' + SQUARE_ELS_IDS[DRAGGED_PIECE_LOCATION]).removeClass(CSS.highlight2);\n      }\n\n      // add highlight to new square\n      if (validSquare(location) === true) {\n        $('#' + SQUARE_ELS_IDS[location]).addClass(CSS.highlight2);\n      }\n\n      // run onDragMove\n      if (typeof cfg.onDragMove === 'function') {\n        cfg.onDragMove(location, DRAGGED_PIECE_LOCATION, DRAGGED_PIECE_SOURCE, DRAGGED_PIECE, deepCopy(CURRENT_POSITION), CURRENT_ORIENTATION);\n      }\n\n      // update state\n      DRAGGED_PIECE_LOCATION = location;\n    }\n\n    function stopDraggedPiece(location) {\n      // determine what the action should be\n      var action = 'drop';\n      if (location === 'offboard' && cfg.dropOffBoard === 'snapback') {\n        action = 'snapback';\n      }\n      if (location === 'offboard' && cfg.dropOffBoard === 'trash') {\n        action = 'trash';\n      }\n\n      // run their onDrop function, which can potentially change the drop action\n      if (cfg.hasOwnProperty('onDrop') === true && typeof cfg.onDrop === 'function') {\n        var newPosition = deepCopy(CURRENT_POSITION);\n\n        // source piece is a spare piece and position is off the board\n        //if (DRAGGED_PIECE_SOURCE === 'spare' && location === 'offboard') {...}\n        // position has not changed; do nothing\n\n        // source piece is a spare piece and position is on the board\n        if (DRAGGED_PIECE_SOURCE === 'spare' && validSquare(location) === true) {\n          // add the piece to the board\n          newPosition[location] = DRAGGED_PIECE;\n        }\n\n        // source piece was on the board and position is off the board\n        if (validSquare(DRAGGED_PIECE_SOURCE) === true && location === 'offboard') {\n          // remove the piece from the board\n          delete newPosition[DRAGGED_PIECE_SOURCE];\n        }\n\n        // source piece was on the board and position is on the board\n        if (validSquare(DRAGGED_PIECE_SOURCE) === true && validSquare(location) === true) {\n          // move the piece\n          delete newPosition[DRAGGED_PIECE_SOURCE];\n          newPosition[location] = DRAGGED_PIECE;\n        }\n\n        var oldPosition = deepCopy(CURRENT_POSITION);\n\n        var result = cfg.onDrop(DRAGGED_PIECE_SOURCE, location, DRAGGED_PIECE, newPosition, oldPosition, CURRENT_ORIENTATION);\n        if (result === 'snapback' || result === 'trash') {\n          action = result;\n        }\n      }\n\n      // do it!\n      if (action === 'snapback') {\n        snapbackDraggedPiece();\n      } else if (action === 'trash') {\n        trashDraggedPiece();\n      } else if (action === 'drop') {\n        dropDraggedPieceOnSquare(location);\n      }\n    }\n\n    //------------------------------------------------------------------------------\n    // Public Methods\n    //------------------------------------------------------------------------------\n\n    // clear the board\n    widget.clear = function (useAnimation) {\n      widget.position({}, useAnimation);\n    };\n\n    /*\n    // get or set config properties\n    // TODO: write this, GitHub Issue #1\n    widget.config = function(arg1, arg2) {\n      // get the current config\n      if (arguments.length === 0) {\n        return deepCopy(cfg);\n      }\n    };\n    */\n\n    // remove the widget from the page\n    widget.destroy = function () {\n      // remove markup\n      containerEl.html('');\n      draggedPieceEl.remove();\n\n      // remove event handlers\n      containerEl.unbind();\n    };\n\n    // shorthand method to get the current FEN\n    widget.fen = function () {\n      return widget.position('fen');\n    };\n\n    // flip orientation\n    widget.flip = function () {\n      widget.orientation('flip');\n    };\n\n    /*\n    // TODO: write this, GitHub Issue #5\n    widget.highlight = function() {\n    \n    };\n    */\n\n    // move pieces\n    widget.move = function () {\n      // no need to throw an error here; just do nothing\n      if (arguments.length === 0) return;\n\n      var useAnimation = true;\n\n      // collect the moves into an object\n      var moves = {};\n      for (var i = 0; i < arguments.length; i++) {\n        // any \"false\" to this function means no animations\n        if (arguments[i] === false) {\n          useAnimation = false;\n          continue;\n        }\n\n        // skip invalid arguments\n        if (validMove(arguments[i]) !== true) {\n          error(2826, 'Invalid move passed to the move method.', arguments[i]);\n          continue;\n        }\n\n        var tmp = arguments[i].split('-');\n        moves[tmp[0]] = tmp[1];\n      }\n\n      // calculate position from moves\n      var newPos = calculatePositionFromMoves(CURRENT_POSITION, moves);\n\n      // update the board\n      widget.position(newPos, useAnimation);\n\n      // return the new position object\n      return newPos;\n    };\n\n    widget.orientation = function (arg) {\n      // no arguments, return the current orientation\n      if (arguments.length === 0) {\n        return CURRENT_ORIENTATION;\n      }\n\n      // set to white or black\n      if (arg === 'white' || arg === 'black') {\n        CURRENT_ORIENTATION = arg;\n        drawBoard();\n        return;\n      }\n\n      // flip orientation\n      if (arg === 'flip') {\n        CURRENT_ORIENTATION = CURRENT_ORIENTATION === 'white' ? 'black' : 'white';\n        drawBoard();\n        return;\n      }\n\n      error(5482, 'Invalid value passed to the orientation method.', arg);\n    };\n\n    widget.position = function (position, useAnimation) {\n      // no arguments, return the current position\n      if (arguments.length === 0) {\n        return deepCopy(CURRENT_POSITION);\n      }\n\n      // get position as FEN\n      if (typeof position === 'string' && position.toLowerCase() === 'fen') {\n        return objToFen(CURRENT_POSITION);\n      }\n\n      // default for useAnimations is true\n      if (useAnimation !== false) {\n        useAnimation = true;\n      }\n\n      // start position\n      if (typeof position === 'string' && position.toLowerCase() === 'start') {\n        position = deepCopy(START_POSITION);\n      }\n\n      // convert FEN to position object\n      if (validFen(position) === true) {\n        position = fenToObj(position);\n      }\n\n      // validate position object\n      if (validPositionObject(position) !== true) {\n        error(6482, 'Invalid value passed to the position method.', position);\n        return;\n      }\n\n      if (useAnimation === true) {\n        // start the animations\n        doAnimations(calculateAnimations(CURRENT_POSITION, position), CURRENT_POSITION, position);\n\n        // set the new position\n        setCurrentPosition(position);\n      }\n      // instant update\n      else {\n          setCurrentPosition(position);\n          drawPositionInstant();\n        }\n    };\n\n    widget.resize = function () {\n      // calulate the new square size\n      SQUARE_SIZE = calculateSquareSize();\n\n      // set board width\n      boardEl.css('width', SQUARE_SIZE * 8 + 'px');\n\n      // set drag piece size\n      draggedPieceEl.css({\n        height: SQUARE_SIZE,\n        width: SQUARE_SIZE\n      });\n\n      // spare pieces\n      if (cfg.sparePieces === true) {\n        containerEl.find('.' + CSS.sparePieces).css('paddingLeft', SQUARE_SIZE + BOARD_BORDER_SIZE + 'px');\n      }\n\n      // redraw the board\n      drawBoard();\n    };\n\n    // set the starting position\n    widget.start = function (useAnimation) {\n      widget.position('start', useAnimation);\n    };\n\n    //------------------------------------------------------------------------------\n    // Browser Events\n    //------------------------------------------------------------------------------\n\n    function isTouchDevice() {\n      return 'ontouchstart' in document.documentElement;\n    }\n\n    // reference: http://www.quirksmode.org/js/detect.html\n    function isMSIE() {\n      return navigator && navigator.userAgent && navigator.userAgent.search(/MSIE/) !== -1;\n    }\n\n    function stopDefault(e) {\n      e.preventDefault();\n    }\n\n    function mousedownSquare(e) {\n      // do nothing if we're not draggable\n      if (cfg.draggable !== true) return;\n\n      var square = $(this).attr('data-square');\n\n      // no piece on this square\n      if (validSquare(square) !== true || CURRENT_POSITION.hasOwnProperty(square) !== true) {\n        return;\n      }\n\n      beginDraggingPiece(square, CURRENT_POSITION[square], e.pageX, e.pageY);\n    }\n\n    function touchstartSquare(e) {\n      // do nothing if we're not draggable\n      if (cfg.draggable !== true) return;\n\n      var square = $(this).attr('data-square');\n\n      // no piece on this square\n      if (validSquare(square) !== true || CURRENT_POSITION.hasOwnProperty(square) !== true) {\n        return;\n      }\n\n      e = e.originalEvent;\n      beginDraggingPiece(square, CURRENT_POSITION[square], e.changedTouches[0].pageX, e.changedTouches[0].pageY);\n    }\n\n    function mousedownSparePiece(e) {\n      // do nothing if sparePieces is not enabled\n      if (cfg.sparePieces !== true) return;\n\n      var piece = $(this).attr('data-piece');\n\n      beginDraggingPiece('spare', piece, e.pageX, e.pageY);\n    }\n\n    function touchstartSparePiece(e) {\n      // do nothing if sparePieces is not enabled\n      if (cfg.sparePieces !== true) return;\n\n      var piece = $(this).attr('data-piece');\n\n      e = e.originalEvent;\n      beginDraggingPiece('spare', piece, e.changedTouches[0].pageX, e.changedTouches[0].pageY);\n    }\n\n    function mousemoveWindow(e) {\n      // do nothing if we are not dragging a piece\n      if (DRAGGING_A_PIECE !== true) return;\n\n      updateDraggedPiece(e.pageX, e.pageY);\n    }\n\n    function touchmoveWindow(e) {\n      // do nothing if we are not dragging a piece\n      if (DRAGGING_A_PIECE !== true) return;\n\n      // prevent screen from scrolling\n      e.preventDefault();\n\n      updateDraggedPiece(e.originalEvent.changedTouches[0].pageX, e.originalEvent.changedTouches[0].pageY);\n    }\n\n    function mouseupWindow(e) {\n      // do nothing if we are not dragging a piece\n      if (DRAGGING_A_PIECE !== true) return;\n\n      // get the location\n      var location = isXYOnSquare(e.pageX, e.pageY);\n\n      stopDraggedPiece(location);\n    }\n\n    function touchendWindow(e) {\n      // do nothing if we are not dragging a piece\n      if (DRAGGING_A_PIECE !== true) return;\n\n      // get the location\n      var location = isXYOnSquare(e.originalEvent.changedTouches[0].pageX, e.originalEvent.changedTouches[0].pageY);\n\n      stopDraggedPiece(location);\n    }\n\n    function mouseenterSquare(e) {\n      // do not fire this event if we are dragging a piece\n      // NOTE: this should never happen, but it's a safeguard\n      if (DRAGGING_A_PIECE !== false) return;\n\n      if (cfg.hasOwnProperty('onMouseoverSquare') !== true || typeof cfg.onMouseoverSquare !== 'function') return;\n\n      // get the square\n      var square = $(e.currentTarget).attr('data-square');\n\n      // NOTE: this should never happen; defensive\n      if (validSquare(square) !== true) return;\n\n      // get the piece on this square\n      var piece = false;\n      if (CURRENT_POSITION.hasOwnProperty(square) === true) {\n        piece = CURRENT_POSITION[square];\n      }\n\n      // execute their function\n      cfg.onMouseoverSquare(square, piece, deepCopy(CURRENT_POSITION), CURRENT_ORIENTATION);\n    }\n\n    function mouseleaveSquare(e) {\n      // do not fire this event if we are dragging a piece\n      // NOTE: this should never happen, but it's a safeguard\n      if (DRAGGING_A_PIECE !== false) return;\n\n      if (cfg.hasOwnProperty('onMouseoutSquare') !== true || typeof cfg.onMouseoutSquare !== 'function') return;\n\n      // get the square\n      var square = $(e.currentTarget).attr('data-square');\n\n      // NOTE: this should never happen; defensive\n      if (validSquare(square) !== true) return;\n\n      // get the piece on this square\n      var piece = false;\n      if (CURRENT_POSITION.hasOwnProperty(square) === true) {\n        piece = CURRENT_POSITION[square];\n      }\n\n      // execute their function\n      cfg.onMouseoutSquare(square, piece, deepCopy(CURRENT_POSITION), CURRENT_ORIENTATION);\n    }\n\n    //------------------------------------------------------------------------------\n    // Initialization\n    //------------------------------------------------------------------------------\n\n    function addEvents() {\n      // prevent browser \"image drag\"\n      $('body').on('mousedown mousemove', '.' + CSS.piece, stopDefault);\n\n      // mouse drag pieces\n      boardEl.on('mousedown', '.' + CSS.square, mousedownSquare);\n      containerEl.on('mousedown', '.' + CSS.sparePieces + ' .' + CSS.piece, mousedownSparePiece);\n\n      // mouse enter / leave square\n      boardEl.on('mouseenter', '.' + CSS.square, mouseenterSquare);\n      boardEl.on('mouseleave', '.' + CSS.square, mouseleaveSquare);\n\n      // IE doesn't like the events on the window object, but other browsers\n      // perform better that way\n      if (isMSIE() === true) {\n        // IE-specific prevent browser \"image drag\"\n        document.ondragstart = function () {\n          return false;\n        };\n\n        $('body').on('mousemove', mousemoveWindow);\n        $('body').on('mouseup', mouseupWindow);\n      } else {\n        $(window).on('mousemove', mousemoveWindow);\n        $(window).on('mouseup', mouseupWindow);\n      }\n\n      // touch drag pieces\n      if (isTouchDevice() === true) {\n        boardEl.on('touchstart', '.' + CSS.square, touchstartSquare);\n        containerEl.on('touchstart', '.' + CSS.sparePieces + ' .' + CSS.piece, touchstartSparePiece);\n        $(window).on('touchmove', touchmoveWindow);\n        $(window).on('touchend', touchendWindow);\n      }\n    }\n\n    function initDom() {\n      // build board and save it in memory\n      containerEl.html(buildBoardContainer());\n      boardEl = containerEl.find('.' + CSS.board);\n\n      if (cfg.sparePieces === true) {\n        sparePiecesTopEl = containerEl.find('.' + CSS.sparePiecesTop);\n        sparePiecesBottomEl = containerEl.find('.' + CSS.sparePiecesBottom);\n      }\n\n      // create the drag piece\n      var draggedPieceId = createId();\n      $('body').append(buildPiece('wP', true, draggedPieceId));\n      draggedPieceEl = $('#' + draggedPieceId);\n\n      // get the border size\n      BOARD_BORDER_SIZE = parseInt(boardEl.css('borderLeftWidth'), 10);\n\n      // set the size and draw the board\n      widget.resize();\n    }\n\n    function init() {\n      if (checkDeps() !== true || expandConfig() !== true) return;\n\n      // create unique IDs for all the elements we will create\n      createElIds();\n\n      initDom();\n      addEvents();\n    }\n\n    // go time\n    init();\n\n    // return the widget object\n    return widget;\n  }; // end window.ChessBoard\n\n  // expose util functions\n  window.ChessBoard.fenToObj = fenToObj;\n  window.ChessBoard.objToFen = objToFen;\n})(); // end anonymous wrapper\n\n\nvar socket = new _phoenix.Socket(\"/socket\", {\n  params: { jwt: window.jwt },\n  logger: function logger(kind, msg, data) {\n    console.log(kind + \": \" + msg, data);\n  }\n});\n\n$(document).ready(function () {\n  $('#newgame').click(function (e) {\n    $.ajax({\n      type: \"POST\",\n      beforeSend: function beforeSend(request) {\n        request.setRequestHeader(\"Authorization\", \"Bearer \" + $(e.currentTarget).data('jwt'));\n      },\n      url: $(e.currentTarget).data('url'),\n      success: function success(data) {\n        location.reload(true);\n        // do something with data\n      }\n    });\n  });\n\n  if ($('#match').length) {\n    var board = ChessBoard('board', 'start');\n    var $input = $(\"#move-input\");\n    var matchId = $('#match').data('id');\n    socket.connect();\n\n    // Now that you are connected, you can join channels with a topic:\n    var channel = socket.channel(\"match:\" + matchId, {});\n    channel.join().receive(\"ok\", function (resp) {\n      console.log(\"Joined successfully\", resp);\n    }).receive(\"error\", function (resp) {\n      console.log(\"Unable to join\", resp);\n    });\n\n    $input.off(\"keypress\").on(\"keypress\", function (e) {\n      if (e.keyCode == 13) {\n        channel.push(\"move\", { an: $input.val() }).receive(\"ok\", function (resp) {\n          console.log(\"Move successfully\", resp);\n        }).receive(\"error\", function (resp) {\n          alert(resp[\"description\"] || resp[\"errors\"]);\n        });\n        $input.val(\"\");\n        console.log(channel);\n      }\n    });\n\n    channel.on(\"game_state_sync\", function (msg) {\n      board.position(msg.fen);\n      $input.prop(\"disabled\", !msg[\"is_current_player\"]);\n    });\n\n    channel.on(\"game_state_updated\", function (msg) {\n      board.position(msg.fen);\n      $input.prop(\"disabled\", !msg[\"is_current_player\"]);\n    });\n  }\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/app.js\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///./js/app.js?")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(2);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(6)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/postcss-loader/index.js!../node_modules/stylus-loader/index.js!./app.styl\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/postcss-loader/index.js!../node_modules/stylus-loader/index.js!./app.styl\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./stylus/app.styl\n// module id = 1\n// module chunks = 0\n\n//# sourceURL=webpack:///./stylus/app.styl?")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.i, "*,:after,:before{margin:0;padding:0;box-sizing:border-box;vertical-align:middle}html{font-size:62.5%}body{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-size:100%;font:2rem/1.5 PT Sans,sans-serif;background-color:#ecf0f1;color:#01161e}hr{margin:2.4rem 0;height:2px;border:0;box-shadow:inset 0 1px 0 rgba(0,0,0,.1),inset 0 -1px 0 hsla(0,0%,100%,.1)}.main{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:100vh}.greeting{width:100%;max-width:54rem;background-color:#124559;color:#eff6e0;text-align:center;padding:4rem 4rem 10rem;border-radius:2px;text-shadow:1px 1px 0 rgba(0,0,0,.1)}.greeting h1,.greeting h2{text-transform:uppercase;letter-spacing:.0625em;font-weight:400}.greeting h1{margin-bottom:.2rem;font-size:2.8rem}.greeting h2{margin-bottom:.2rem;font-size:2rem}.greeting p{font-style:italic;color:#769eac}a{color:#2980b9}a:hover{color:#3498db}", ""]);\n\n// exports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/postcss-loader!./~/stylus-loader!./stylus/app.styl\n// module id = 2\n// module chunks = 0\n\n//# sourceURL=webpack:///./stylus/app.styl?./~/css-loader!./~/postcss-loader!./~/stylus-loader')},function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function() {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\tvar result = [];\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar item = this[i];\n\t\t\tif(item[2]) {\n\t\t\t\tresult.push("@media " + item[2] + "{" + item[1] + "}");\n\t\t\t} else {\n\t\t\t\tresult.push(item[1]);\n\t\t\t}\n\t\t}\n\t\treturn result.join("");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === "string")\n\t\t\tmodules = [[null, modules, ""]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === "number")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 3\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?')},function(module,exports,__webpack_require__){eval('(function (global, factory) {\n true ? factory(exports) :\ntypeof define === \'function\' && define.amd ? define([\'exports\'], factory) :\nfactory(global.Phoenix = global.Phoenix || {});\n}(this, (function (exports) {\n"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n// Phoenix Channels JavaScript client\n//\n// ## Socket Connection\n//\n// A single connection is established to the server and\n// channels are multiplexed over the connection.\n// Connect to the server using the `Socket` class:\n//\n//     let socket = new Socket("/socket", {params: {userToken: "123"}})\n//     socket.connect()\n//\n// The `Socket` constructor takes the mount point of the socket,\n// the authentication params, as well as options that can be found in\n// the Socket docs, such as configuring the `LongPoll` transport, and\n// heartbeat.\n//\n// ## Channels\n//\n// Channels are isolated, concurrent processes on the server that\n// subscribe to topics and broker events between the client and server.\n// To join a channel, you must provide the topic, and channel params for\n// authorization. Here\'s an example chat room example where `"new_msg"`\n// events are listened for, messages are pushed to the server, and\n// the channel is joined with ok/error/timeout matches:\n//\n//     let channel = socket.channel("room:123", {token: roomToken})\n//     channel.on("new_msg", msg => console.log("Got message", msg) )\n//     $input.onEnter( e => {\n//       channel.push("new_msg", {body: e.target.val}, 10000)\n//        .receive("ok", (msg) => console.log("created message", msg) )\n//        .receive("error", (reasons) => console.log("create failed", reasons) )\n//        .receive("timeout", () => console.log("Networking issue...") )\n//     })\n//     channel.join()\n//       .receive("ok", ({messages}) => console.log("catching up", messages) )\n//       .receive("error", ({reason}) => console.log("failed join", reason) )\n//       .receive("timeout", () => console.log("Networking issue. Still waiting...") )\n//\n//\n// ## Joining\n//\n// Creating a channel with `socket.channel(topic, params)`, binds the params to\n// `channel.params`, which are sent up on `channel.join()`.\n// Subsequent rejoins will send up the modified params for\n// updating authorization params, or passing up last_message_id information.\n// Successful joins receive an "ok" status, while unsuccessful joins\n// receive "error".\n//\n// ## Duplicate Join Subscriptions\n//\n// While the client may join any number of topics on any number of channels,\n// the client may only hold a single subscription for each unique topic at any\n// given time. When attempting to create a duplicate subscription,\n// the server will close the existing channel, log a warning, and\n// spawn a new channel for the topic. The client will have their\n// `channel.onClose` callbacks fired for the existing channel, and the new\n// channel join will have its receive hooks processed as normal.\n//\n// ## Pushing Messages\n//\n// From the previous example, we can see that pushing messages to the server\n// can be done with `channel.push(eventName, payload)` and we can optionally\n// receive responses from the push. Additionally, we can use\n// `receive("timeout", callback)` to abort waiting for our other `receive` hooks\n//  and take action after some period of waiting. The default timeout is 5000ms.\n//\n//\n// ## Socket Hooks\n//\n// Lifecycle events of the multiplexed connection can be hooked into via\n// `socket.onError()` and `socket.onClose()` events, ie:\n//\n//     socket.onError( () => console.log("there was an error with the connection!") )\n//     socket.onClose( () => console.log("the connection dropped") )\n//\n//\n// ## Channel Hooks\n//\n// For each joined channel, you can bind to `onError` and `onClose` events\n// to monitor the channel lifecycle, ie:\n//\n//     channel.onError( () => console.log("there was an error!") )\n//     channel.onClose( () => console.log("the channel has gone away gracefully") )\n//\n// ### onError hooks\n//\n// `onError` hooks are invoked if the socket connection drops, or the channel\n// crashes on the server. In either case, a channel rejoin is attempted\n// automatically in an exponential backoff manner.\n//\n// ### onClose hooks\n//\n// `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n// closed on the server, or 2). The client explicitly closed, by calling\n// `channel.leave()`\n//\n//\n// ## Presence\n//\n// The `Presence` object provides features for syncing presence information\n// from the server with the client and handling presences joining and leaving.\n//\n// ### Syncing initial state from the server\n//\n// `Presence.syncState` is used to sync the list of presences on the server\n// with the client\'s state. An optional `onJoin` and `onLeave` callback can\n// be provided to react to changes in the client\'s local presences across\n// disconnects and reconnects with the server.\n//\n// `Presence.syncDiff` is used to sync a diff of presence join and leave\n// events from the server, as they happen. Like `syncState`, `syncDiff`\n// accepts optional `onJoin` and `onLeave` callbacks to react to a user\n// joining or leaving from a device.\n//\n// ### Listing Presences\n//\n// `Presence.list` is used to return a list of presence information\n// based on the local state of metadata. By default, all presence\n// metadata is returned, but a `listBy` function can be supplied to\n// allow the client to select which metadata to use for a given presence.\n// For example, you may have a user online from different devices with\n// a metadata status of "online", but they have set themselves to "away"\n// on another device. In this case, the app may choose to use the "away"\n// status for what appears on the UI. The example below defines a `listBy`\n// function which prioritizes the first metadata which was registered for\n// each user. This could be the first tab they opened, or the first device\n// they came online from:\n//\n//     let state = {}\n//     state = Presence.syncState(state, stateFromServer)\n//     let listBy = (id, {metas: [first, ...rest]}) => {\n//       first.count = rest.length + 1 // count of this user\'s presences\n//       first.id = id\n//       return first\n//     }\n//     let onlineUsers = Presence.list(state, listBy)\n//\n//\n// ### Example Usage\n//\n//     // detect if user has joined for the 1st time or from another tab/device\n//     let onJoin = (id, current, newPres) => {\n//       if(!current){\n//         console.log("user has entered for the first time", newPres)\n//       } else {\n//         console.log("user additional presence", newPres)\n//       }\n//     }\n//     // detect if user has left from all tabs/devices, or is still present\n//     let onLeave = (id, current, leftPres) => {\n//       if(current.metas.length === 0){\n//         console.log("user has left from all devices", leftPres)\n//       } else {\n//         console.log("user left from a device", leftPres)\n//       }\n//     }\n//     let presences = {} // client\'s initial empty presence state\n//     // receive initial presence data from server, sent after join\n//     myChannel.on("presence_state", state => {\n//       presences = Presence.syncState(presences, state, onJoin, onLeave)\n//       displayUsers(Presence.list(presences))\n//     })\n//     // receive "presence_diff" from server, containing join/leave events\n//     myChannel.on("presence_diff", diff => {\n//       presences = Presence.syncDiff(presences, diff, onJoin, onLeave)\n//       this.setState({users: Presence.list(room.presences, listBy)})\n//     })\n//\nvar VSN = "1.0.0";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 10000;\nvar WS_CLOSE_NORMAL = 1000;\nvar CHANNEL_STATES = {\n  closed: "closed",\n  errored: "errored",\n  joined: "joined",\n  joining: "joining",\n  leaving: "leaving"\n};\nvar CHANNEL_EVENTS = {\n  close: "phx_close",\n  error: "phx_error",\n  join: "phx_join",\n  reply: "phx_reply",\n  leave: "phx_leave"\n};\nvar TRANSPORTS = {\n  longpoll: "longpoll",\n  websocket: "websocket"\n};\n\nvar Push = function () {\n\n  // Initializes the Push\n  //\n  // channel - The Channel\n  // event - The event, for example `"phx_join"`\n  // payload - The payload, for example `{user_id: 123}`\n  // timeout - The push timeout in milliseconds\n  //\n  function Push(channel, event, payload, timeout) {\n    _classCallCheck(this, Push);\n\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || {};\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n\n  _createClass(Push, [{\n    key: "resend",\n    value: function resend(timeout) {\n      this.timeout = timeout;\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n      this.send();\n    }\n  }, {\n    key: "send",\n    value: function send() {\n      if (this.hasReceived("timeout")) {\n        return;\n      }\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload,\n        ref: this.ref\n      });\n    }\n  }, {\n    key: "receive",\n    value: function receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({ status: status, callback: callback });\n      return this;\n    }\n\n    // private\n\n  }, {\n    key: "matchReceive",\n    value: function matchReceive(_ref) {\n      var status = _ref.status,\n          response = _ref.response,\n          ref = _ref.ref;\n\n      this.recHooks.filter(function (h) {\n        return h.status === status;\n      }).forEach(function (h) {\n        return h.callback(response);\n      });\n    }\n  }, {\n    key: "cancelRefEvent",\n    value: function cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n      this.channel.off(this.refEvent);\n    }\n  }, {\n    key: "cancelTimeout",\n    value: function cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n  }, {\n    key: "startTimeout",\n    value: function startTimeout() {\n      var _this = this;\n\n      if (this.timeoutTimer) {\n        return;\n      }\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n\n      this.channel.on(this.refEvent, function (payload) {\n        _this.cancelRefEvent();\n        _this.cancelTimeout();\n        _this.receivedResp = payload;\n        _this.matchReceive(payload);\n      });\n\n      this.timeoutTimer = setTimeout(function () {\n        _this.trigger("timeout", {});\n      }, this.timeout);\n    }\n  }, {\n    key: "hasReceived",\n    value: function hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n  }, {\n    key: "trigger",\n    value: function trigger(status, response) {\n      this.channel.trigger(this.refEvent, { status: status, response: response });\n    }\n  }]);\n\n  return Push;\n}();\n\nvar Channel = exports.Channel = function () {\n  function Channel(topic, params, socket) {\n    var _this2 = this;\n\n    _classCallCheck(this, Channel);\n\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = params || {};\n    this.socket = socket;\n    this.bindings = [];\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.rejoinTimer = new Timer(function () {\n      return _this2.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive("ok", function () {\n      _this2.state = CHANNEL_STATES.joined;\n      _this2.rejoinTimer.reset();\n      _this2.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n      _this2.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this2.rejoinTimer.reset();\n      _this2.socket.log("channel", "close " + _this2.topic + " " + _this2.joinRef());\n      _this2.state = CHANNEL_STATES.closed;\n      _this2.socket.remove(_this2);\n    });\n    this.onError(function (reason) {\n      if (_this2.isLeaving() || _this2.isClosed()) {\n        return;\n      }\n      _this2.socket.log("channel", "error " + _this2.topic, reason);\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive("timeout", function () {\n      if (!_this2.isJoining()) {\n        return;\n      }\n      _this2.socket.log("channel", "timeout " + _this2.topic, _this2.joinPush.timeout);\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this2.trigger(_this2.replyEventName(ref), payload);\n    });\n  }\n\n  _createClass(Channel, [{\n    key: "rejoinUntilConnected",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: "join",\n    value: function join() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.joinedOnce) {\n        throw "tried to join multiple times. \'join\' can only be called a single time per channel instance";\n      } else {\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n  }, {\n    key: "onClose",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n  }, {\n    key: "onError",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: "on",\n    value: function on(event, callback) {\n      this.bindings.push({ event: event, callback: callback });\n    }\n  }, {\n    key: "off",\n    value: function off(event) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return bind.event !== event;\n      });\n    }\n  }, {\n    key: "canPush",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: "push",\n    value: function push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n      if (!this.joinedOnce) {\n        throw "tried to push \'" + event + "\' to \'" + this.topic + "\' before joining. Use channel.join() before pushing events";\n      }\n      var pushEvent = new Push(this, event, payload, timeout);\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n\n    // Leaves the channel\n    //\n    // Unsubscribes from server events, and\n    // instructs channel to terminate on server\n    //\n    // Triggers onClose() hooks\n    //\n    // To receive leave acknowledgements, use the a `receive`\n    // hook to bind to the server ack, ie:\n    //\n    //     channel.leave().receive("ok", () => alert("left!") )\n    //\n\n  }, {\n    key: "leave",\n    value: function leave() {\n      var _this3 = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      this.state = CHANNEL_STATES.leaving;\n      var onClose = function onClose() {\n        _this3.socket.log("channel", "leave " + _this3.topic);\n        _this3.trigger(CHANNEL_EVENTS.close, "leave", _this3.joinRef());\n      };\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive("ok", function () {\n        return onClose();\n      }).receive("timeout", function () {\n        return onClose();\n      });\n      leavePush.send();\n      if (!this.canPush()) {\n        leavePush.trigger("ok", {});\n      }\n\n      return leavePush;\n    }\n\n    // Overridable message hook\n    //\n    // Receives all events for specialized message handling\n    // before dispatching to the channel callbacks.\n    //\n    // Must return the payload, modified or unmodified\n\n  }, {\n    key: "onMessage",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n\n    // private\n\n  }, {\n    key: "isMember",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: "joinRef",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: "sendJoin",\n    value: function sendJoin(timeout) {\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: "rejoin",\n    value: function rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      if (this.isLeaving()) {\n        return;\n      }\n      this.sendJoin(timeout);\n    }\n  }, {\n    key: "trigger",\n    value: function trigger(event, payload, ref) {\n      var close = CHANNEL_EVENTS.close,\n          error = CHANNEL_EVENTS.error,\n          leave = CHANNEL_EVENTS.leave,\n          join = CHANNEL_EVENTS.join;\n\n      if (ref && [close, error, leave, join].indexOf(event) >= 0 && ref !== this.joinRef()) {\n        return;\n      }\n      var handledPayload = this.onMessage(event, payload, ref);\n      if (payload && !handledPayload) {\n        throw "channel onMessage callbacks must return the payload, modified or unmodified";\n      }\n\n      this.bindings.filter(function (bind) {\n        return bind.event === event;\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref);\n      });\n    }\n  }, {\n    key: "replyEventName",\n    value: function replyEventName(ref) {\n      return "chan_reply_" + ref;\n    }\n  }, {\n    key: "isClosed",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: "isErrored",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: "isJoined",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: "isJoining",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: "isLeaving",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }]);\n\n  return Channel;\n}();\n\nvar Socket = exports.Socket = function () {\n\n  // Initializes the Socket\n  //\n  // endPoint - The string WebSocket endpoint, ie, "ws://example.com/socket",\n  //                                               "wss://example.com"\n  //                                               "/socket" (inherited host & protocol)\n  // opts - Optional configuration\n  //   transport - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n  //               Defaults to WebSocket with automatic LongPoll fallback.\n  //   encode - The function to encode outgoing messages. Defaults to JSON:\n  //\n  //     (payload, callback) => callback(JSON.stringify(payload))\n  //\n  //   decode - The function to decode incoming messages. Defaults to JSON:\n  //\n  //     (payload, callback) => callback(JSON.parse(payload))\n  //\n  //   timeout - The default timeout in milliseconds to trigger push timeouts.\n  //             Defaults `DEFAULT_TIMEOUT`\n  //   heartbeatIntervalMs - The millisec interval to send a heartbeat message\n  //   reconnectAfterMs - The optional function that returns the millsec\n  //                      reconnect interval. Defaults to stepped backoff of:\n  //\n  //     function(tries){\n  //       return [1000, 5000, 10000][tries - 1] || 10000\n  //     }\n  //\n  //   logger - The optional function for specialized logging, ie:\n  //     `logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n  //\n  //   longpollerTimeout - The maximum timeout of a long poll AJAX request.\n  //                        Defaults to 20s (double the server long poll timer).\n  //\n  //   params - The optional params to pass when connecting\n  //\n  // For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n  //\n  function Socket(endPoint) {\n    var _this4 = this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Socket);\n\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || window.WebSocket || LongPoll;\n    this.defaultEncoder = function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n    this.defaultDecoder = function (payload, callback) {\n      return callback(JSON.parse(payload));\n    };\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n    this.reconnectAfterMs = opts.reconnectAfterMs || function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.logger = opts.logger || function () {}; // noop\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.params = opts.params || {};\n    this.endPoint = endPoint + "/" + TRANSPORTS.websocket;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(function () {\n      _this4.disconnect(function () {\n        return _this4.connect();\n      });\n    }, this.reconnectAfterMs);\n  }\n\n  _createClass(Socket, [{\n    key: "protocol",\n    value: function protocol() {\n      return location.protocol.match(/^https/) ? "wss" : "ws";\n    }\n  }, {\n    key: "endPointURL",\n    value: function endPointURL() {\n      var uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params), { vsn: VSN });\n      if (uri.charAt(0) !== "/") {\n        return uri;\n      }\n      if (uri.charAt(1) === "/") {\n        return this.protocol() + ":" + uri;\n      }\n\n      return this.protocol() + "://" + location.host + uri;\n    }\n  }, {\n    key: "disconnect",\n    value: function disconnect(callback, code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n        if (code) {\n          this.conn.close(code, reason || "");\n        } else {\n          this.conn.close();\n        }\n        this.conn = null;\n      }\n      callback && callback();\n    }\n\n    // params - The params to send when connecting, for example `{user_id: userToken}`\n\n  }, {\n    key: "connect",\n    value: function connect(params) {\n      var _this5 = this;\n\n      if (params) {\n        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");\n        this.params = params;\n      }\n      if (this.conn) {\n        return;\n      }\n\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.timeout = this.longpollerTimeout;\n      this.conn.onopen = function () {\n        return _this5.onConnOpen();\n      };\n      this.conn.onerror = function (error) {\n        return _this5.onConnError(error);\n      };\n      this.conn.onmessage = function (event) {\n        return _this5.onConnMessage(event);\n      };\n      this.conn.onclose = function (event) {\n        return _this5.onConnClose(event);\n      };\n    }\n\n    // Logs the message. Override `this.logger` for specialized logging. noops by default\n\n  }, {\n    key: "log",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n\n    // Registers callbacks for connection state change events\n    //\n    // Examples\n    //\n    //    socket.onError(function(error){ alert("An error occurred") })\n    //\n\n  }, {\n    key: "onOpen",\n    value: function onOpen(callback) {\n      this.stateChangeCallbacks.open.push(callback);\n    }\n  }, {\n    key: "onClose",\n    value: function onClose(callback) {\n      this.stateChangeCallbacks.close.push(callback);\n    }\n  }, {\n    key: "onError",\n    value: function onError(callback) {\n      this.stateChangeCallbacks.error.push(callback);\n    }\n  }, {\n    key: "onMessage",\n    value: function onMessage(callback) {\n      this.stateChangeCallbacks.message.push(callback);\n    }\n  }, {\n    key: "onConnOpen",\n    value: function onConnOpen() {\n      var _this6 = this;\n\n      this.log("transport", "connected to " + this.endPointURL());\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      if (!this.conn.skipHeartbeat) {\n        clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(function () {\n          return _this6.sendHeartbeat();\n        }, this.heartbeatIntervalMs);\n      }\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n  }, {\n    key: "onConnClose",\n    value: function onConnClose(event) {\n      this.log("transport", "close", event);\n      this.triggerChanError();\n      clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n  }, {\n    key: "onConnError",\n    value: function onConnError(error) {\n      this.log("transport", error);\n      this.triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n  }, {\n    key: "triggerChanError",\n    value: function triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel.trigger(CHANNEL_EVENTS.error);\n      });\n    }\n  }, {\n    key: "connectionState",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return "connecting";\n        case SOCKET_STATES.open:\n          return "open";\n        case SOCKET_STATES.closing:\n          return "closing";\n        default:\n          return "closed";\n      }\n    }\n  }, {\n    key: "isConnected",\n    value: function isConnected() {\n      return this.connectionState() === "open";\n    }\n  }, {\n    key: "remove",\n    value: function remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c.joinRef() !== channel.joinRef();\n      });\n    }\n  }, {\n    key: "channel",\n    value: function channel(topic) {\n      var chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n  }, {\n    key: "push",\n    value: function push(data) {\n      var _this7 = this;\n\n      var topic = data.topic,\n          event = data.event,\n          payload = data.payload,\n          ref = data.ref;\n\n      var callback = function callback() {\n        _this7.encode(data, function (result) {\n          _this7.conn.send(result);\n        });\n      };\n      this.log("push", topic + " " + event + " (" + ref + ")", payload);\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n\n    // Return the next message ref, accounting for overflows\n\n  }, {\n    key: "makeRef",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n  }, {\n    key: "sendHeartbeat",\n    value: function sendHeartbeat() {\n      if (!this.isConnected()) {\n        return;\n      }\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log("transport", "heartbeat timeout. Attempting to re-establish connection");\n        this.conn.close(WS_CLOSE_NORMAL, "hearbeat timeout");\n        return;\n      }\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });\n    }\n  }, {\n    key: "flushSendBuffer",\n    value: function flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: "onConnMessage",\n    value: function onConnMessage(rawMessage) {\n      var _this8 = this;\n\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n            event = msg.event,\n            payload = msg.payload,\n            ref = msg.ref;\n\n        if (ref && ref === _this8.pendingHeartbeatRef) {\n          _this8.pendingHeartbeatRef = null;\n        }\n\n        _this8.log("receive", (payload.status || "") + " " + topic + " " + event + " " + (ref && "(" + ref + ")" || ""), payload);\n        _this8.channels.filter(function (channel) {\n          return channel.isMember(topic);\n        }).forEach(function (channel) {\n          return channel.trigger(event, payload, ref);\n        });\n        _this8.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n  }]);\n\n  return Socket;\n}();\n\nvar LongPoll = exports.LongPoll = function () {\n  function LongPoll(endPoint) {\n    _classCallCheck(this, LongPoll);\n\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function () {}; // noop\n    this.onerror = function () {}; // noop\n    this.onmessage = function () {}; // noop\n    this.onclose = function () {}; // noop\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n\n    this.poll();\n  }\n\n  _createClass(LongPoll, [{\n    key: "normalizeEndpoint",\n    value: function normalizeEndpoint(endPoint) {\n      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)\\/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);\n    }\n  }, {\n    key: "endpointURL",\n    value: function endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n    }\n  }, {\n    key: "closeAndRetry",\n    value: function closeAndRetry() {\n      this.close();\n      this.readyState = SOCKET_STATES.connecting;\n    }\n  }, {\n    key: "ontimeout",\n    value: function ontimeout() {\n      this.onerror("timeout");\n      this.closeAndRetry();\n    }\n  }, {\n    key: "poll",\n    value: function poll() {\n      var _this9 = this;\n\n      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n        return;\n      }\n\n      Ajax.request("GET", this.endpointURL(), "application/json", null, this.timeout, this.ontimeout.bind(this), function (resp) {\n        if (resp) {\n          var status = resp.status,\n              token = resp.token,\n              messages = resp.messages;\n\n          _this9.token = token;\n        } else {\n          var status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(function (msg) {\n              return _this9.onmessage({ data: JSON.stringify(msg) });\n            });\n            _this9.poll();\n            break;\n          case 204:\n            _this9.poll();\n            break;\n          case 410:\n            _this9.readyState = SOCKET_STATES.open;\n            _this9.onopen();\n            _this9.poll();\n            break;\n          case 0:\n          case 500:\n            _this9.onerror();\n            _this9.closeAndRetry();\n            break;\n          default:\n            throw "unhandled poll status " + status;\n        }\n      });\n    }\n  }, {\n    key: "send",\n    value: function send(body) {\n      var _this10 = this;\n\n      Ajax.request("POST", this.endpointURL(), "application/json", body, this.timeout, this.onerror.bind(this, "timeout"), function (resp) {\n        if (!resp || resp.status !== 200) {\n          _this10.onerror(resp && resp.status);\n          _this10.closeAndRetry();\n        }\n      });\n    }\n  }, {\n    key: "close",\n    value: function close(code, reason) {\n      this.readyState = SOCKET_STATES.closed;\n      this.onclose();\n    }\n  }]);\n\n  return LongPoll;\n}();\n\nvar Ajax = exports.Ajax = function () {\n  function Ajax() {\n    _classCallCheck(this, Ajax);\n  }\n\n  _createClass(Ajax, null, [{\n    key: "request",\n    value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (window.XDomainRequest) {\n        var req = new XDomainRequest(); // IE8, IE9\n        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        var _req = window.XMLHttpRequest ? new window.XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n        new ActiveXObject("Microsoft.XMLHTTP"); // IE6, IE5\n        this.xhrRequest(_req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n  }, {\n    key: "xdomainRequest",\n    value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      var _this11 = this;\n\n      req.timeout = timeout;\n      req.open(method, endPoint);\n      req.onload = function () {\n        var response = _this11.parseJSON(req.responseText);\n        callback && callback(response);\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      // Work around bug in IE9 that requires an attached onprogress handler\n      req.onprogress = function () {};\n\n      req.send(body);\n    }\n  }, {\n    key: "xhrRequest",\n    value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      var _this12 = this;\n\n      req.open(method, endPoint, true);\n      req.timeout = timeout;\n      req.setRequestHeader("Content-Type", accept);\n      req.onerror = function () {\n        callback && callback(null);\n      };\n      req.onreadystatechange = function () {\n        if (req.readyState === _this12.states.complete && callback) {\n          var response = _this12.parseJSON(req.responseText);\n          callback(response);\n        }\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n    }\n  }, {\n    key: "parseJSON",\n    value: function parseJSON(resp) {\n      if (!resp || resp === "") {\n        return null;\n      }\n\n      try {\n        return JSON.parse(resp);\n      } catch (e) {\n        console && console.log("failed to parse JSON response", resp);\n        return null;\n      }\n    }\n  }, {\n    key: "serialize",\n    value: function serialize(obj, parentKey) {\n      var queryStr = [];\n      for (var key in obj) {\n        if (!obj.hasOwnProperty(key)) {\n          continue;\n        }\n        var paramKey = parentKey ? parentKey + "[" + key + "]" : key;\n        var paramVal = obj[key];\n        if ((typeof paramVal === "undefined" ? "undefined" : _typeof(paramVal)) === "object") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));\n        }\n      }\n      return queryStr.join("&");\n    }\n  }, {\n    key: "appendParams",\n    value: function appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? "&" : "?";\n      return "" + url + prefix + this.serialize(params);\n    }\n  }]);\n\n  return Ajax;\n}();\n\nAjax.states = { complete: 4 };\n\nvar Presence = exports.Presence = {\n  syncState: function syncState(currentState, newState, onJoin, onLeave) {\n    var _this13 = this;\n\n    var state = this.clone(currentState);\n    var joins = {};\n    var leaves = {};\n\n    this.map(state, function (key, presence) {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, function (key, newPresence) {\n      var currentPresence = state[key];\n      if (currentPresence) {\n        var newRefs = newPresence.metas.map(function (m) {\n          return m.phx_ref;\n        });\n        var curRefs = currentPresence.metas.map(function (m) {\n          return m.phx_ref;\n        });\n        var joinedMetas = newPresence.metas.filter(function (m) {\n          return curRefs.indexOf(m.phx_ref) < 0;\n        });\n        var leftMetas = currentPresence.metas.filter(function (m) {\n          return newRefs.indexOf(m.phx_ref) < 0;\n        });\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = _this13.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins: joins, leaves: leaves }, onJoin, onLeave);\n  },\n  syncDiff: function syncDiff(currentState, _ref2, onJoin, onLeave) {\n    var joins = _ref2.joins,\n        leaves = _ref2.leaves;\n\n    var state = this.clone(currentState);\n    if (!onJoin) {\n      onJoin = function onJoin() {};\n    }\n    if (!onLeave) {\n      onLeave = function onLeave() {};\n    }\n\n    this.map(joins, function (key, newPresence) {\n      var currentPresence = state[key];\n      state[key] = newPresence;\n      if (currentPresence) {\n        var _state$key$metas;\n\n        (_state$key$metas = state[key].metas).unshift.apply(_state$key$metas, _toConsumableArray(currentPresence.metas));\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, function (key, leftPresence) {\n      var currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      var refsToRemove = leftPresence.metas.map(function (m) {\n        return m.phx_ref;\n      });\n      currentPresence.metas = currentPresence.metas.filter(function (p) {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  },\n  list: function list(presences, chooser) {\n    if (!chooser) {\n      chooser = function chooser(key, pres) {\n        return pres;\n      };\n    }\n\n    return this.map(presences, function (key, presence) {\n      return chooser(key, presence);\n    });\n  },\n\n\n  // private\n\n  map: function map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map(function (key) {\n      return func(key, obj[key]);\n    });\n  },\n  clone: function clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// Creates a timer that accepts a `timerCalc` function to perform\n// calculated timeout retries, such as exponential backoff.\n//\n// ## Examples\n//\n//    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n//      return [1000, 5000, 10000][tries - 1] || 10000\n//    })\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//    reconnectTimer.scheduleTimeout() // fires after 5000\n//    reconnectTimer.reset()\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//\n\nvar Timer = function () {\n  function Timer(callback, timerCalc) {\n    _classCallCheck(this, Timer);\n\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  _createClass(Timer, [{\n    key: "reset",\n    value: function reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n\n    // Cancels any previous scheduleTimeout and schedules callback\n\n  }, {\n    key: "scheduleTimeout",\n    value: function scheduleTimeout() {\n      var _this14 = this;\n\n      clearTimeout(this.timer);\n\n      this.timer = setTimeout(function () {\n        _this14.tries = _this14.tries + 1;\n        _this14.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n  }]);\n\n  return Timer;\n}();\n\n})));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/phoenix/priv/static/phoenix.js\n// module id = 4\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/phoenix/priv/static/phoenix.js?')},function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction isLinkToSubmitParent(element) {\n  var isLinkTag = element.tagName === 'A';\n  var shouldSubmitParent = element.getAttribute('data-submit') === 'parent';\n\n  return isLinkTag && shouldSubmitParent;\n}\n\nfunction getClosestForm(element) {\n  while (element && element !== document && element.nodeType === Node.ELEMENT_NODE) {\n    if (element.tagName === 'FORM') {\n      return element;\n    }\n    element = element.parentNode;\n  }\n  return null;\n}\n\nfunction didHandleSubmitLinkClick(element) {\n  while (element && element.getAttribute) {\n    if (isLinkToSubmitParent(element)) {\n      var message = element.getAttribute('data-confirm');\n      if (message === null || confirm(message)) {\n        getClosestForm(element).submit();\n      }\n      return true;\n    } else {\n      element = element.parentNode;\n    }\n  }\n  return false;\n}\n\nwindow.addEventListener('click', function (event) {\n  if (event.target && didHandleSubmitLinkClick(event.target)) {\n    event.preventDefault();\n    return false;\n  }\n}, false);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/phoenix_html/priv/static/phoenix_html.js\n// module id = 5\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/phoenix_html/priv/static/phoenix_html.js?")},function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName("head")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === "undefined") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === "undefined") options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === "top") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === "bottom") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error("Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement("style");\n\tstyleElement.type = "text/css";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement("link");\n\tlinkElement.rel = "stylesheet";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute("media", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 6\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(0);\nmodule.exports = __webpack_require__(1);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi js/app.js stylus/app.styl\n// module id = 7\n// module chunks = 0\n\n//# sourceURL=webpack:///multi_js/app.js_stylus/app.styl?")}]);